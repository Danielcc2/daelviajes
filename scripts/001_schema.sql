create extension if not exists pgcrypto;
-- profiles
create table if not exists public.profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  email text, nombre text, is_admin boolean not null default false, avatar_url text, created_at timestamptz default now()
);
create or replace function public.handle_new_user() returns trigger language plpgsql security definer as $$
begin insert into public.profiles (id, email) values (new.id, new.email); return new; end; $$;
drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created after insert on auth.users for each row execute function public.handle_new_user();

-- is_admin helper (se define después de crear profiles)
create or replace function public.is_admin() returns boolean language sql stable as $$
  select coalesce((select is_admin from public.profiles where id = auth.uid()), false);
$$;
-- RLS para profiles (dueño y admin)
alter table public.profiles enable row level security;
drop policy if exists profiles_select_self on public.profiles;
create policy profiles_select_self on public.profiles for select using ( id = auth.uid() );
drop policy if exists profiles_select_admin on public.profiles;
create policy profiles_select_admin on public.profiles for select using (
  exists (select 1 from public.profiles me where me.id = auth.uid() and me.is_admin)
);
drop policy if exists profiles_update_self on public.profiles;
create policy profiles_update_self on public.profiles for update using ( id = auth.uid() ) with check ( id = auth.uid() );
drop policy if exists profiles_update_admin on public.profiles;
create policy profiles_update_admin on public.profiles for update using (
  exists (select 1 from public.profiles me where me.id = auth.uid() and me.is_admin)
) with check ( true );

-- posts
create table if not exists public.posts (
  id uuid primary key default gen_random_uuid(),
  slug text unique not null,
  titulo text not null,
  resumen text,
  contenido text,
  categoria text check (categoria in ('Guías','Itinerarios','Reseñas','Consejos')),
  publicado boolean not null default false,
  autor_id uuid references public.profiles(id) on delete set null,
  fecha_pub timestamptz default now()
);
alter table public.posts enable row level security;
create policy posts_select_publicados on public.posts for select using (publicado = true);
create policy posts_select_admin on public.posts for select using (public.is_admin());
create policy posts_ins_admin on public.posts for insert with check (public.is_admin());
create policy posts_upd_admin on public.posts for update using (public.is_admin()) with check (public.is_admin());
create policy posts_del_admin on public.posts for delete using (public.is_admin());

-- comentarios
create table if not exists public.comentarios (
  id bigint generated by default as identity primary key,
  post_id uuid not null references public.posts(id) on delete cascade,
  user_id uuid references public.profiles(id) on delete set null,
  texto text not null, created_at timestamptz default now()
);
alter table public.comentarios enable row level security;
create policy comentarios_select_publicos on public.comentarios for select using ( exists (select 1 from public.posts p where p.id = post_id and p.publicado = true) );
create policy comentarios_insert_authed on public.comentarios for insert with check ( auth.uid() = user_id );
create policy comentarios_delete_owner_admin on public.comentarios for delete using ( auth.uid() = user_id or public.is_admin() );

-- favoritos
create table if not exists public.favoritos (
  user_id uuid not null references public.profiles(id) on delete cascade,
  post_id uuid not null references public.posts(id) on delete cascade,
  created_at timestamptz default now(), primary key (user_id, post_id)
);
alter table public.favoritos enable row level security;
create policy favoritos_select_owner on public.favoritos for select using ( auth.uid() = user_id );
create policy favoritos_insert_owner on public.favoritos for insert with check ( auth.uid() = user_id );
create policy favoritos_delete_owner on public.favoritos for delete using ( auth.uid() = user_id );
create or replace view public.favoritos_view as select f.created_at, p.slug, p.titulo, p.resumen, p.categoria from public.favoritos f join public.posts p on p.id = f.post_id where f.user_id = auth.uid();

-- itinerarios (usuario y públicos)
create table if not exists public.itinerarios_usuario (
  id uuid primary key default gen_random_uuid(), user_id uuid not null references public.profiles(id) on delete cascade,
  titulo text not null, contenido text not null, updated_at timestamptz default now()
);
alter table public.itinerarios_usuario enable row level security;
create policy itins_select_owner on public.itinerarios_usuario for select using ( auth.uid() = user_id );
create policy itins_insert_owner on public.itinerarios_usuario for insert with check ( auth.uid() = user_id );
create policy itins_update_owner on public.itinerarios_usuario for update using ( auth.uid() = user_id ) with check ( auth.uid() = user_id );
create policy itins_delete_owner on public.itinerarios_usuario for delete using ( auth.uid() = user_id );

create table if not exists public.itinerarios_publicos (
  id uuid primary key default gen_random_uuid(), slug text unique not null, titulo text not null, resumen text, contenido text, fecha_pub timestamptz default now()
);
alter table public.itinerarios_publicos enable row level security;
create policy itins_pub_select_all on public.itinerarios_publicos for select using ( true );
create policy itins_pub_mut_admin on public.itinerarios_publicos for all using ( public.is_admin() ) with check ( public.is_admin() );

-- contacto
create table if not exists public.mensajes_contacto (
  id bigint generated by default as identity primary key, nombre text not null, email text not null, asunto text not null, mensaje text not null, created_at timestamptz default now()
);
alter table public.mensajes_contacto enable row level security;
create policy contacto_insert_all on public.mensajes_contacto for insert with check ( true );
create policy contacto_select_admin on public.mensajes_contacto for select using ( public.is_admin() );

-- contenidos (modo edición admin)
create table if not exists public.contenidos (
  id text primary key, html text not null, updated_at timestamptz default now()
);
alter table public.contenidos enable row level security;
drop policy if exists contenidos_select_all on public.contenidos;
create policy contenidos_select_all on public.contenidos for select using ( true );
drop policy if exists contenidos_ins_admin on public.contenidos;
create policy contenidos_ins_admin on public.contenidos for insert with check ( public.is_admin() );
drop policy if exists contenidos_upd_admin on public.contenidos;
create policy contenidos_upd_admin on public.contenidos for update using ( public.is_admin() ) with check ( public.is_admin() );
drop policy if exists contenidos_del_admin on public.contenidos;
create policy contenidos_del_admin on public.contenidos for delete using ( public.is_admin() );

-- índices
create index if not exists idx_posts_categoria on public.posts(categoria);
create index if not exists idx_posts_fecha on public.posts(fecha_pub desc);
create index if not exists idx_comentarios_post on public.comentarios(post_id);
create index if not exists idx_favoritos_user on public.favoritos(user_id, created_at desc);

-- Storage policies para bucket público
-- Nota: en algunos proyectos, el rol del editor SQL no es propietario de storage.objects
-- y no puede crear/alterar políticas. Intentamos crearlas y si no hay permisos, emitimos un aviso.
do $$
begin
  begin
    create policy storage_public_read_imagenes_posts
    on storage.objects for select using ( bucket_id = 'imagenes-posts' );
  exception when insufficient_privilege then
    raise notice 'Sin privilegios para crear políticas en storage.objects. Crea las políticas desde Storage > Policies en el panel.';
  when duplicate_object then
    raise notice 'Política storage_public_read_imagenes_posts ya existe.';
  end;

  begin
    create policy storage_admin_write_imagenes_posts
    on storage.objects for insert
    with check ( bucket_id = 'imagenes-posts' and public.is_admin() );
  exception when insufficient_privilege then
    raise notice 'Sin privilegios para crear políticas en storage.objects (insert).';
  when duplicate_object then
    raise notice 'Política storage_admin_write_imagenes_posts ya existe.';
  end;

  begin
    create policy storage_admin_update_imagenes_posts
    on storage.objects for update
    using ( bucket_id = 'imagenes-posts' and public.is_admin() )
    with check ( bucket_id = 'imagenes-posts' and public.is_admin() );
  exception when insufficient_privilege then
    raise notice 'Sin privilegios para crear políticas en storage.objects (update).';
  when duplicate_object then
    raise notice 'Política storage_admin_update_imagenes_posts ya existe.';
  end;

  begin
    create policy storage_admin_delete_imagenes_posts
    on storage.objects for delete
    using ( bucket_id = 'imagenes-posts' and public.is_admin() );
  exception when insufficient_privilege then
    raise notice 'Sin privilegios para crear políticas en storage.objects (delete).';
  when duplicate_object then
    raise notice 'Política storage_admin_delete_imagenes_posts ya existe.';
  end;
end $$;

-- Bucket de avatares (lectura pública, escritura del dueño)
do $$
begin
  begin
    perform storage.create_bucket('avatars', public => true);
  exception when insufficient_privilege then
    raise notice 'Sin privilegios para crear bucket avatars. Créalo en Storage > Buckets (public)';
  when others then null; -- bucket puede existir
  end;

  -- Políticas RLS para avatars
  begin
    create policy avatars_public_read on storage.objects
    for select using ( bucket_id = 'avatars' );
  exception when insufficient_privilege then
    raise notice 'Sin privilegios para crear políticas en storage.objects (avatars select).';
  when duplicate_object then
    raise notice 'Política avatars_public_read ya existe.';
  end;

  begin
    create policy avatars_owner_insert on storage.objects
    for insert with check (
      bucket_id = 'avatars'
      and auth.uid()::text = (storage.foldername(name))[1]
    );
  exception when insufficient_privilege then
    raise notice 'Sin privilegios para crear políticas en storage.objects (avatars insert).';
  when duplicate_object then
    raise notice 'Política avatars_owner_insert ya existe.';
  end;

  begin
    create policy avatars_owner_update on storage.objects
    for update using (
      bucket_id = 'avatars'
      and auth.uid()::text = (storage.foldername(name))[1]
    ) with check (
      bucket_id = 'avatars'
      and auth.uid()::text = (storage.foldername(name))[1]
    );
  exception when insufficient_privilege then
    raise notice 'Sin privilegios para crear políticas en storage.objects (avatars update).';
  when duplicate_object then
    raise notice 'Política avatars_owner_update ya existe.';
  end;

  begin
    create policy avatars_owner_delete on storage.objects
    for delete using (
      bucket_id = 'avatars'
      and auth.uid()::text = (storage.foldername(name))[1]
    );
  exception when insufficient_privilege then
    raise notice 'Sin privilegios para crear políticas en storage.objects (avatars delete).';
  when duplicate_object then
    raise notice 'Política avatars_owner_delete ya existe.';
  end;
end $$;
